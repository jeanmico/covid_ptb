---
title: "Air surface construction and analysis"
author: "Jean Costello"
date: "4/19/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r, libraries, echo=FALSE, message=FALSE, warning=FALSE}

require(RColorBrewer); require(ggplot2)
require(mapdata); require(maptools)
library(raster)
#library(zipcode) 
library(choroplethr)
library(rgdal)
library(ggmap)
library(sp)
require("plyr"); require(dplyr)
library(tgp)
library(mgcv)
library(gstat)
library(automap)
library(raster) 
library(dismo)
library(reshape)
library(reshape2)
library(leaflet); library(rgeos)
library(leaflet.extras)
library(rgdal)
require(ggspatial)
library(mapview); library(webshot)
library(rasterVis)
library(sf)
library(tidyverse)
library(stringr)
library(viridis)
library(scico)
library(patchwork)
library(tmap)

# install.packages("ncdf4")
library(ncdf4)
```


## Air surface

```{r read files}
county_ref = read.csv('~/covid/california_county_dict.csv')
epa_raw = read.csv('~/covid/EPA_2020_pm25_CA.csv')
```

How many counties do not have an EPA sensor?
```{r}
epa_counties <- unique(epa_raw$COUNTY_CODE)
print(nrow(county_ref) - length(epa_counties))
```
Which counties do not have a sensor?
```{r counties with no sensors}
missing_fips <- setdiff(county_ref$county_fips, epa_counties)
print(county_ref[county_ref$county_fips %in% missing_fips, ]$county_name)
```
Where are these counties located?
```{r counties with no sensors map}


```

Which counties have multiple sensors?
```{r counties with multiple sensors}
sensor_locations <- epa_raw %>% 
  dplyr::select(Site.ID, Site.Name, CBSA_CODE, CBSA_NAME, STATE_CODE, STATE, COUNTY_CODE, COUNTY, SITE_LATITUDE, SITE_LONGITUDE) %>%
  distinct()

sensors_by_county <- sensor_locations %>%
  group_by(COUNTY_CODE) %>% dplyr::summarise(num_sensors = n())

# add number of EPA sensors to the county reference df
county_ref = merge(county_ref, sensors_by_county, by.x = 'county_fips', by.y = 'COUNTY_CODE', all.x = TRUE)
county_ref[is.na(county_ref)] <- 0
print(county_ref[county_ref$num_sensors > 1, c('county_name', 'num_sensors')]) # print the names and number of sensors in counties with more than 1
```
```{r sensors map}

```

In counties with multiple sensors, how well do they agree?

```{r read air surface}
pm25 <- raster("~/covid/V4NA03_PM25_NA_201801_201812-RH35.nc")
pmdat <- projectRaster(pm25, crs = "+proj=longlat +datum=WGS84")

```

```{r determine county multipliers}
epa_rast <- raster::extract(pmdat, SpatialPointsDataFrame(sensor_locations[c("SITE_LONGITUDE", 'SITE_LATITUDE')], 
                                                          data = sensor_locations['Site.ID']), df=TRUE)
epa_rast <- cbind(epa_rast, sensor_locations$Site.ID)
colnames(epa_rast) <- c('ID', 'PM2.5', 'Site.ID') #rename columns

epa <- merge(epa_raw, epa_rast, by='Site.ID', all.x = TRUE)

epa <- epa %>% mutate(multiplier = Daily.Mean.PM2.5.Concentration/PM2.5)

county_mult <- epa %>% dplyr::group_by(COUNTY_CODE, Date) %>%
  dplyr::summarise(
    mean_mult = mean(multiplier), stdev_mult = sd(multiplier), num_measures = n())
```

```{r standard deviations plot}
#histograms of standard deviations (for multiple sensors within county)
sd_hist <- ggplot(filter(county_mult, num_measures>1), aes(x=stdev_mult)) +
  geom_histogram()  +
  scale_y_continuous(trans='log10') +
  ylab('Count') +
  xlab('Standard deviation of sensors within counties') +
  theme_minimal()
sd_hist
```

The range of standard deviations of sensors within counties is `r range(county_mult$stdev_mult, na.rm = TRUE)`.

How many multipliers are negative? `r nrow(county_mult[county_mult$mean_mult < 0, ])`

Read in a map of California counties, show number of sensors per county
```{r}
ca_county = rgdal::readOGR('/Users/student/covid/cb_2018_us_county_5m')
ca_county <- subset(ca_county, STATEFP == '06')
ca_county$county_int = as.integer(ca_county$COUNTYFP)
ca_county <- merge(ca_county, county_ref, by.x = 'county_int', by.y = 'county_fips')

mycolors = c('#D3D3D3', '#bae4b3','#74c476','#31a354','#006d2c')

county_map <- tm_shape(ca_county) + tm_polygons(col = 'num_sensors', breaks = c(0,1,2,6,10,14),
                                                palette = mycolors)


county_map
```
redo this map using POC == 1 to see how many sensors we retain

Also should map the sensors themselves here.

Map the 2018 surface.

```{r}
pm25_ca <- mask(pm25, ca_county)

rast_18 <- tm_shape(pm25_ca, bbox = ca_county) + tm_raster() +
  tm_shape(ca_county) + tm_polygons(alpha = 0) +
  tm_layout(legend.position = c('right', 'top'))

rast_18

```


Multiply each county.

```{r}
# deal with counties with no measurements



# basic raster with extent
r<- raster(ncol = ncol(pm25_ca), nrow = nrow(pm25_ca))
extent(r) <- extent(ca_county)

pm25_ca_nad <- projectRaster(pm25_ca, crs = '+proj=longlat +datum=NAD83 +no_defs')


# the more correct approach:
#   for each day, rasterize the shapefile; the value of each county is its multiplier
#   multiply the rasters
#   store each day as an output
datelist <- seq(as.Date('2020-01-01'), as.Date('2020-12-31'), by='days')
for (tmpdate in datelist[1]) {
  
  datemult <- county_mult %>% filter(as.Date(Date, '%d/%m/%Y') == tmpdate)
  print(nrow(datemult))
  county_full <- merge(ca_county, datemult, by.x = 'county_int', by.y = 'COUNTY_CODE')
  
  # make a raster of the county file, value set to county multiplier
  rast_mult <- rasterize(county_full, r, 'mean_mult')
  
  rs_rast_mult <- resample(rast_mult, pm25_ca)
  print('yay')
  # multiply the two rasters and save the output
  rast_date = rs_rast_mult * pm25_ca
}

tm_shape(rast_date, bbox = ca_county) + tm_raster()

res(rs_rast_mult)



rastname_base = '/Volumes/Padlock/covid/rasts/'


```

Map the 2020-01-01 surface. Visually check to see that it makes sense.

```{r}


```

















